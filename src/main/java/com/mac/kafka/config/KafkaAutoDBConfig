package com.mac.kafka.config;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.map.MapUtil;
import cn.hutool.core.util.ObjUtil;
import com.alibaba.fastjson2.JSON;
import com.alibaba.fastjson2.JSONObject;
import com.mac.kafka.ClassMethodArgs;
import com.mac.kafka.KafkaConsumerProperties;
import com.mac.kafka.KafkaMessageHandler;
import com.mac.kafka.query.KafkaQueryConfigService;
import lombok.Getter;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.springframework.beans.BeansException;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.kafka.annotation.KafkaListenerAnnotationBeanPostProcessor;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.KafkaListenerContainerFactory;
import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
import org.springframework.kafka.config.MethodKafkaListenerEndpoint;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;
import org.springframework.messaging.handler.annotation.support.MessageHandlerMethodFactory;
import org.springframework.util.ReflectionUtils;

import javax.annotation.PostConstruct;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * The type Kafka config.
 *
 * @author mac
 */
@Configuration
@Slf4j
@EnableConfigurationProperties(KafkaConsumerProperties.class)
@ConditionalOnBean(value = KafkaConsumerProperties.class, name = "kafkaConsumerProperties")
public class KafkaAutoDBConfig implements ApplicationContextAware {

    private final KafkaConsumerProperties kafkaConsumerProperties;

    private final KafkaListenerEndpointRegistry registry;
    private final KafkaListenerAnnotationBeanPostProcessor<String, String> postProcessor;
    @Getter
    private Map<String, DefaultKafkaConsumerFactory<String, String>> consumerFactoryMap = new ConcurrentHashMap<>();

    public KafkaAutoDBConfig(KafkaConsumerProperties kafkaConsumerProperties, KafkaListenerEndpointRegistry registry, KafkaListenerAnnotationBeanPostProcessor<String, String> postProcessor) {
        this.kafkaConsumerProperties = kafkaConsumerProperties;
        this.registry = registry;
        this.postProcessor = postProcessor;
    }


    public Map<String, Object> consumerConfigs() {
        Map<String, Object> propsMap = new HashMap<>(16);
        propsMap.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaConsumerProperties.getBootstrapServers());
        propsMap.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaConsumerProperties.getGroupId());
        //是否自动提交偏移量，默认值是true，为了避免出现重复数据和数据丢失，可以把它设置为false，然后手动提交偏移量
        propsMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, kafkaConsumerProperties.isEnableAutoCommit());
        //自动提交的时间间隔，自动提交开启时生效
        propsMap.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, kafkaConsumerProperties.getAutoCommitInterval());
        //该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：
        //earliest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费分区的记录
        //latest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据（在消费者启动之后生成的记录）
        //none：当各分区都存在已提交的offset时，从提交的offset开始消费；只要有一个分区不存在已提交的offset，则抛出异常
        propsMap.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, kafkaConsumerProperties.getAutoOffsetReset());
        //两次poll之间的最大间隔，默认值为5分钟。如果超过这个间隔会触发reBalance
        propsMap.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, kafkaConsumerProperties.getMaxPollIntervalTime());
        //这个参数定义了poll方法最多可以拉取多少条消息，默认值为500。如果在拉取消息的时候新消息不足500条，那有多少返回多少；如果超过500条，每次只返回500。
        //这个默认值在有些场景下太大，有些场景很难保证能够在5min内处理完500条消息，
        //如果消费者无法在5分钟内处理完500条消息的话就会触发reBalance,
        //然后这批消息会被分配到另一个消费者中，还是会处理不完，这样这批消息就永远也处理不完。
        //要避免出现上述问题，提前评估好处理一条消息最长需要多少时间，然后覆盖默认的max.poll.records参数
        //注：需要开启BatchListener批量监听才会生效，如果不开启BatchListener则不会出现reBalance情况
        propsMap.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, kafkaConsumerProperties.getMaxPollRecords());
        //当broker多久没有收到consumer的心跳请求后就触发reBalance，默认值是10s
        propsMap.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, kafkaConsumerProperties.getSessionTimeout());
        //序列化（建议使用Json，这种序列化方式可以无需额外配置传输实体类）
        propsMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        propsMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        return propsMap;
    }

    public ConsumerFactory<Object, Object> consumerFactory() {
//        //配置消费者的 Json 反序列化的可信赖包，反序列化实体类需要
//        try(JsonDeserializer<Object> deserializer = new JsonDeserializer<>()) {
//            deserializer.trustedPackages("*");
//            return new DefaultKafkaConsumerFactory<>(consumerConfigs(), new JsonDeserializer<>(), deserializer);
//        }
        return new DefaultKafkaConsumerFactory<>(consumerConfigs());
    }

    @Bean
    public KafkaListenerContainerFactory<ConcurrentMessageListenerContainer<Object, Object>> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<Object, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        //在侦听器容器中运行的线程数，一般设置为 机器数*分区数
        factory.setConcurrency(kafkaConsumerProperties.getConcurrency());
        //消费监听接口监听的主题不存在时，默认会报错，所以设置为false忽略错误
        factory.setMissingTopicsFatal(kafkaConsumerProperties.isMissingTopicsFatal());
        //自动提交关闭，需要设置手动消息确认
//        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL_IMMEDIATE);
        factory.getContainerProperties().setPollTimeout(kafkaConsumerProperties.getPollTimeout());
        //设置为批量监听，需要用List接收
        //factory.setBatchListener(true);
        return factory;
    }

    /**
     * 此方式主要为db应用做组件支撑的
     */
    @SneakyThrows
    public void init() {
        if (!kafkaConsumerProperties.getDbEnabled()) {
            return;
        } else if (CollUtil.isEmpty(kafkaConsumerProperties.getConsumerClientIds())) {
            if (initClientId()) {
                log.info("kafka-db方式客户端id初始化成功！");
            }else {
                log.info("kafka-db方式客户端id初始化失败，请检查数据库topic缺失！");
            }
            return;
        }
        List<String> topicsListen = kafkaConsumerProperties.getTopicsListen();
        MessageHandlerMethodFactory methodFactory = postProcessor.getMessageHandlerMethodFactory();
        if (kafkaConsumerProperties.getDbEnabled() && topicsListen.size() == kafkaConsumerProperties.getBeanMethod().size()) {
            for (int i = 0; i < topicsListen.size(); i++) {
                String kafkaBroker = kafkaConsumerProperties.getBootstrapServers();
                if (!consumerFactoryMap.containsKey(kafkaBroker)) {
                    JSONObject props = ObjUtil.isEmpty(kafkaConsumerProperties) ? new JSONObject() : JSON.parseObject(JSON.toJSONString(kafkaConsumerProperties));
                    DefaultKafkaConsumerFactory<String, String> consumerFactory = new DefaultKafkaConsumerFactory<>(props);
                    consumerFactoryMap.put(kafkaBroker, consumerFactory);
                }
                DefaultKafkaConsumerFactory<String, String> consumerFactory = consumerFactoryMap.get(kafkaBroker);
                ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
                factory.setConsumerFactory(consumerFactory);
                factory.setConcurrency(kafkaConsumerProperties.getConcurrency());
                MethodKafkaListenerEndpoint<String, String> endpoint = new MethodKafkaListenerEndpoint<>();
                ClassMethodArgs classMethodArgs = ClassMethodArgs.parseMethod(kafkaConsumerProperties.getBeanMethod().get(i));
                Class<?> clazz = Class.forName(classMethodArgs.getClassName());
                // 获取构造函数
                Constructor<?> constructor = clazz.getDeclaredConstructor(long.class);
                Method method = ReflectionUtils.findMethod(clazz, classMethodArgs.getMethod(), classMethodArgs.getArgsClasses());
                endpoint.setBean(constructor.newInstance(kafkaConsumerProperties.getConsumerClientIds().get(i)));
                endpoint.setMethod(method);
                endpoint.setMessageHandlerMethodFactory(methodFactory);
                endpoint.setId("ConsumerZoningProcessing-" + kafkaConsumerProperties.getConsumerClientIds().get(i));
                endpoint.setGroupId(kafkaConsumerProperties.getGroupId());
                endpoint.setTopicPartitions();
                endpoint.setTopics(topicsListen.get(i));//Arrays.asList(kafkaConsumerProperties.getTopicsListen()).toArray(new String[0])
                endpoint.setConcurrency(kafkaConsumerProperties.getConcurrency());
                endpoint.setBatchListener(true);
                registry.registerListenerContainer(endpoint, factory, false);
            }
            registry.start();
            log.info("自定义反射方式启动完成");
        } else {
            log.info("自定义反射配置方式失败，请检查应用配置！");
        }
    }

    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        init();
    }


    public boolean initClientId() {
        KafkaQueryConfigService kafkaQueryConfigService= applicationContext.getBean(KafkaQueryConfigService.class);
        Map<String,Map<String,String>> resultMap=kafkaQueryConfigService.getClientIdByTopics(kafkaConsumerProperties.getTopicsListen());
        if (MapUtil.isNotEmpty(resultMap)) {
            Map<String,Map<String,String>> finalResultMap = resultMap;
            List<Long> clientIds = new ArrayList<>();
            List<String> validTopic = new ArrayList<>();
            List<String> invalidTopic = new ArrayList<>();
            kafkaConsumerProperties.getTopicsListen().forEach(e -> {
                if (finalResultMap.containsKey(e) && finalResultMap.get(e).containsKey("id")) {
                    Long clientId = Long.valueOf(finalResultMap.get(e).get("id"));
                    clientIds.add(clientId);
                    validTopic.add(e);
                }else{
                    invalidTopic.add(e);
                }
            });
            kafkaConsumerProperties.setTopicsListen(validTopic);
            kafkaConsumerProperties.setConsumerClientIds(clientIds);
            if(validTopic.size()>0){
                log.info("AutoDB-kafka有效的 topic: {}",  validTopic);
            }
            if(invalidTopic.size()>0){
                log.info("AutoDB-kafka无效的 topic: {}",  invalidTopic);
            }
            return  true;
        } else {
            log.info("kafkadb方式客户端id未配置！");
            return false;
        }
    }


    /**
     * 使用反射调用指定全路径类中的方法，该方法接受一个列表作为参数并返回一个Map<String, String>
     *
     * @param className       全路径类名
     * @param methodName      方法名
     * @param listElementType 列表元素的类型
     * @param listParams      方法的参数列表
     * @return 方法的返回值，类型为Map<String, String>
     * @return java.util.Map<java.lang.String, java.lang.String>
     * @throws Exception 反射调用时可能抛出的异常
     * @author zj
     * @Date 15:49 2024/7/10
     **/
    public static Map<String, String> invokeMethodWithListParam(String className, String methodName, Class<?> listElementType, List<?> listParams) throws Exception {
        Class<?> clazz = Class.forName(className);
        Method method = clazz.getMethod(methodName, List.class);
        Object instance = clazz.getDeclaredConstructor().newInstance();
        Object result = method.invoke(instance, listParams);
        if (result instanceof Map) {
            @SuppressWarnings("unchecked") // 这里需要进行类型检查，但因为我们知道期望的类型，所以使用unchecked警告
            Map<String, String> mapResult = (Map<String, String>) result;
            return mapResult;
        } else {
            throw new ClassCastException("Method did not return a Map<String, String> as expected.");
        }
    }

    public boolean initClientId2() {
        String className = "com.mac.kafka.service.impl.KafkaConsumerConfigServiceImpl";
        String methodName = "getClientIdByTopics";
        Map<String, String> resultMap = null;
        try {
            resultMap = invokeMethodWithListParam(className, methodName, String.class, kafkaConsumerProperties.getTopicsListen());
            if (MapUtil.isNotEmpty(resultMap)) {
                Map<String, String> finalResultMap = resultMap;
                kafkaConsumerProperties.getTopicsListen().forEach(e -> {
                    kafkaConsumerProperties.getConsumerClientIds().add(Long.valueOf(finalResultMap.get(e)));
                });
                return true;
            } else {
                log.info("kafkadb方式客户端id未配置！");
                return false;
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }




}
